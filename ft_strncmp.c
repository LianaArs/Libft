/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strncmp.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: klupin <klupin@student.21-school.ru>       +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/10/17 16:42:16 by klupin            #+#    #+#             */
/*   Updated: 2021/10/17 18:07:19 by klupin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

/*По аналогии с strcmp в MAN говорится, что функция лексикографически сравнивает
 * NULL-терминированные строки s1 и s2, которые передаются в параметрах функции.
 * Функция возвращает целое число больше, равное или меньше
 * чем 0 в зависимости от того, больше, равна или меньше строка s1, чем строка
 * s2. Сравнение снова выполняется с использованием безаковых символов,
 * так что '\200' больше, чем '\0'. Однако разница между strncmp
 * и strcmp в том, что мы будем искать строку s1 только до ее n-ой позиции.
 * n задается в параметрах.*/

/* Сначала мы объявляем нашу переменную i как size_t. Мы делаем это потому, что
 * параметр, который мы принимаем для n, является size_t. Нам нужно будет
 * сравнить значение n с нашим значением i, поэтому они должны быть одинаковыми.
 * Мы устанавливаем i в 0, чтобы поместить нас в начало строки, когда начинаем
 * цикл. Затем мы проверяем, равно ли заданное нами значение n 0. Если да, то мы
 * возвращаем 0. Если нет, мы начинаем наш цикл, который требует, чтобы три
 * условия были истинными для того, чтобы это произошло.
 * Мы хотим, чтобы наш цикл выполнялся до тех пор, пока наша строка
 * не достигла своего конца И пока символ в позиции i в s1 будет
 * такой же, как символ в позиции i в s2 И пока наш счетчик
 * переменная i меньше n - 1. Мы вычитаем 1 из данного n, потому что
 * переменная size_t часто используется для функции выделения памяти и будет
 * будет иметь полный размер строки. Мы вычитаем 1, чтобы компенсировать тот
 * факт, что данный size_t не должен быть задан как 0. Если мы обнаружим
 * разницу в символах, или наша переменная i станет размером с n
 * минус 1, или мы достигаем конца s1, мы завершаем цикл. Затем мы возвращаем
 * разницу между текущим символом в s1 в позиции i и
 * текущего символа в s2 в позиции i. ПРИМЕЧАНИЕ: Мы приводим символы как
 * беззнаковые символы, как указано в MAN.*/

int	ft_strncmp(const char *s1, const char *s2, size_t n)
{
	size_t	i;

	i = 0;
	if (n == 0)
		return (0);
	while (s1[i] != '\0' && s1[i] == s2[i] && i < n - 1)
		i++;
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
}
