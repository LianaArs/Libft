/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: klupin <klupin@student.21-school.ru>       +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/10/17 19:57:06 by klupin            #+#    #+#             */
/*   Updated: 2021/10/28 15:52:51 by klupin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

/*Эта функция выделяет память и возвращает новую строку, заканчивающуюся
 * символом '\0', которая является результатом конкатенации параметров s1 и s2.
 * Если выделение не удалось, функция возвращает NULL.
 * Мы начинаем с объявления трех переменных. Первые две будут счетчиками,которые
 * мы будем использовать для перемещения по нашим строкам. Третья - это новая
 * строка, под которую мы будем выделять память, чтобы вернуть конкатенацию
 * строк с нашими параметрами.
 * Мы установим обе переменные счетчика в 0, так как мы хотим, чтобы оба
 * счетчика начинались с начала соответствующих строк. Затем мы выделяем память
 * с помощью функции malloc и комбинации с использованием наших ранее созданных
 * функций ft_strlen. Мы используем функцию ft_strlen для обеих строк параметров
 * чтобы определить полную длину для конкатенации и добавляем 1 к этой длине,
 * чтобы убедиться, что мы можем добавить завершающее '\0'. Если выделение не
 * удалось, мы вернем NULL.
 * Если выделение прошло успешно, мы начинаем конкатенацию заданных строк.
 * Мы начинаем со строки s1 со стандартным циклом, говорящим, что пока мы не
 * достигли конца строки, мы продолжаем. Мы помещаем индекс нашей новой строки
 * str и нашего параметра s1 в i, который в данный момент равен 0. Затем мы
 * пробегаем по длине s1, помещая каждый символ s1 в str. После этого мы
 * переходим к следующему циклу.
 * Этот следующий цикл точно такой же, как и предыдущий, за исключением того,
 * что мы используем переменную счетчика j. В данный момент j равна 0. Для нашей
 * новой строки str мы устанавливаем индекс, равный предыдущему счетчику i плюс
 * наш новый счетчик j. Это позволяет нам оставаться на той позиции индекса,
 * на которой мы закончили предыдущий цикл, так как это будет значение i в конце
 * предыдущего цикла плюс текущее значение j, равное 0. Мы используем j для
 * установки индекса нашей строки s2 и продолжаем цикл, пока не достигнем конца
 * s2. Когда конец s2 будет достигнут, мы добавим завершающее '\0' к концу нашей
 * свежей строки и вернем новую строку, которая является свежей конкатенацией
 * наших параметров.*/

char	*ft_strjoin(char const *s1, char const *s2)
{
	int		i;
	int		j;
	char	*str;

	i = 0;
	j = 0;
	if (!s1 || !s2)
		return (0);
	str = (char *)malloc(sizeof(char) * (ft_strlen(s1) + ft_strlen(s2) + 1));
	if (str == NULL)
		return (NULL);
	while (s1[i] != '\0')
	{
		str[i] = s1[i];
		i++;
	}
	while (s2[j] != '\0')
	{
		str[i + j] = s2[j];
		j++;
	}
	str[i + j] = '\0';
	return (str);
}
