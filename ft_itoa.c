/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_itoa.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: klupin <klupin@student.21-school.ru>       +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/10/17 22:40:36 by klupin            #+#    #+#             */
/*   Updated: 2021/10/28 16:09:42 by klupin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

/*Эта функция выделяет память и возвращает "свежую" строку символов,
 * заканчивающуюся символом '\0', который является char-эквивалентом переданного
 * в параметре int. Отрицательные числа также должны управляться. Если
 * распределение не удалось, функция возвращает NULL.
 * ПРИМЕЧАНИЕ: Это рекурсивная функция. Если вы не знакомы с рекурсивными
 * функциями, то это функция, которая либо вызывает сама себя, либо находится
 * в потенциальном цикле вызовов функций.
 * Мы начинаем с создания переменной char string. Это то, что будет возвращать
 * наша функция. Затем мы выделяем память для нашей строковой переменной str.
 * ПРИМЕЧАНИЕ: Мы выделяем память только для размера 2 char. Это связано с тем,
 * что мы будем выполнять эту функцию многократно и хотим выделять память только
 * по мере необходимости. Мы используем размер 2 в нашей функции malloc, потому
 * что мы хотим сделать один символ за раз из заданного int n, одно место для
 * одноразрядного числа, преобразованного в char, и завершающего '\0', которое
 * необходимо для завершения строки этого отдельного char. Если распределение
 * не удалось, мы возвращаем NULL. Мы также хотим компенсировать вероятность
 * того, что переданное нам число int является наименьшим из возможных целых
 * чисел. Если нам передали это число в параметре, то мы обязательно вернем
 * его строку.
 * Далее мы хотим проверить, является ли переданное в параметре int
 * отрицательным числом. Если int n меньше нуля, то мы делаем индексную позицию
 * 0 нашей "свежей" строки str отрицательным знаком, а позицию 1 - завершающей.
 * Затем мы устанавливаем строку str равной ft_strjoin с нашей str в качестве
 * параметра и рекурсивно вызываем нашу функцию с параметром -n, чтобы
 * превратить отрицательное число int в положительное. Затем мы запускаем
 * функцию заново.
 * Ниже мы говорим, что если int n, переданное в параметре, больше 10, то мы
 * хотим рекурсивно разбить его на части, чтобы снова собрать его как строку.
 * Для этого мы устанавливаем нашу выделенную в памяти строку str равной нашей
 * ранее созданной функции ft_strjoin и передаем ей параметр нашей функции
 * ft_itoa с n, деленным на 10, и нашей функции ft_itoa с n по модулю 10.
 * Именно здесь идея о том, как работает рекурсия, может быть трудна для
 * понимания. Это использование ft_strjoin произойдет только позже, потому что
 * мы снова вызовем ft_itoa. Это разделит наш заданный int на 10, возьмет
 * результат и запустит функцию заново, последовательно разбивая ее на части,
 * пока мы не получим самое первое число в нашем int. Например, если мы начали
 * с числа n = 123, то вызов ft_itoa(n / 10) и ft_itoa(n % 10) на самом деле
 * будет ft_itoa(123 / 10) и ft_itoa(123 % 10). Это вызовет ft_itoa на значении
 * 12 для деления на 10 и вызовет ft_itoa на значении 3 для нашего модуля 10.
 * Так мы разбиваем число на отдельные цифры. Для результата 3 мы начнем эту
 * функцию заново и пропустим этот раздел, так как теперь это будет значение
 * меньше 10. В следующей строке else if мы видим, что если число больше 0 и
 * меньше 10, мы преобразуем его в отдельную строку, которая будет "3\0", потому
 * что у нас должно быть завершающее '\0'. Эта отдельная строка будет возвращена
 * в функцию ft_strjoin, в которой она была вызвана, чтобы соединиться со
 * строкой, которая будет возвращена из другого параметра. Но что случилось с
 * ft_itoa(123 / 10)? Это дало нам число 12, которое нужно подставить в функцию
 * ft_itoa. Поскольку это число все еще больше 10, мы создадим оператор if,
 * который будет использовать ft_strjoin с двумя функциями ft_itoa, переданными
 * в его параметрах, но на этот раз для значения 12. Как и в случае с полным
 * значением 123, теперь мы разделим 12 на отдельные 1 и 2. Запускаем ft_itoa
 * на каждом отдельном числе. Поскольку оба числа меньше 10, но больше 0, мы
 * преобразуем их в строку. Итак, на данный момент у нас есть строки "1\0",
 * "2\0", а из нашего предыдущего вызова ft_itoa(123 % 10) у нас есть строка
 * "3\0". Поскольку мы достигли конечной точки возврата для нашей рекурсии,
 * мы объединим сначала строки "1\0" и "2\0" внутри функции ft_strjoin,
 * в которой они сейчас находятся, превратив их в строку "12\0". Это возвращает
 * нас на один уровень вверх и теперь соединим "12\0" со строкой "3\0", получив
 * строку "123\0". Поскольку теперь она помещена в нашу строку str
 * (ПРИМЕЧАНИЕ: мы выделяли память для каждой строки при каждом вызове ft_itoa
 * в нашей рекурсии), мы можем вернуть ее, поскольку все число было
 * преобразовано в строку char. Таким образом, наша функция завершается.
 * Если вам было трудно представить это в голове, попробуйте изобразить функцию
 * на листе бумаги. Она должна быть похожа на двоичное дерево.*/

static int	ft_get_size(int n)
{
	int	size;

	size = 0;
	if (n <= 0)
		size++;
	while (n != 0)
	{
		n = n / 10;
		size++;
	}
	return (size);
}

static void	ft_fill_res(int size, int offset, int n, char *res)
{
	while (size > offset)
	{
		res[size - 1] = n % 10 + '0';
		n = n / 10;
		size--;
	}
}

char	*ft_itoa(int n)
{
	int		offset;
	int		size;
	char	*res;

	offset = 0;
	size = ft_get_size(n);
	res = (char *) malloc(sizeof(char) * size + 1);
	if (res == NULL)
		return (0);
	if (n == -2147483648)
	{
		res[0] = '-';
		res[1] = '2';
		n = 147483648;
		offset = 2;
	}
	if (n < 0)
	{
		res[0] = '-';
		offset = 1;
		n = -n;
	}
	ft_fill_res(size, offset, n, res);
	res[size] = '\0';
	return (res);
}
