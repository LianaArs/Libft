/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstmap.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: klupin <klupin@student.21-school.ru>       +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/10/18 01:14:47 by klupin            #+#    #+#             */
/*   Updated: 2021/10/18 01:19:46 by klupin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

/*Создает новый список в результате последовательного применения функции 'f'.
 *Функция 'del' используется для удаления содержимого элемента, если это
 *необходимо. Эта функция принимает список lst, переданный в параметре,
 *применяет к каждому звену функцию f (также переданную в параметре),
 *создает и возвращает "свежий" список. В результате происходит
 *последовательное применение функции рекурсивно, пока не будет достигнут
 *конец списка и возвращен newlist.
 *Сначала мы создаем новую переменную newlist структуры t_list. Затем мы
 *убеждаемся, что как переданный список, так и функция f не являются NULL.
 *Если это так, то мы вернем NULL. Если нет, мы выполним функцию f на ссылке
 *lst и поместим ее в нашу переменную-ссылку newlist. ПРИМЕЧАНИЕ: Мы должны
 *предположить, что функция f выделяет память для нашей переменной newlist
 *на основе данных lst. Затем мы проверяем, не является ли newlist нулевым,
 *а также не является ли элемент next ссылки lst NULL. Если ни то, ни другое
 *не является NULL, мы устанавливаем элемент newlist next равным функции
 *ft_lstmap, которой был передан элемент lst next (следующая за ним ссылка),
 *а также функция f. Это позволяет нам рекурсивно применять функцию f ко всем
 *ссылкам и выделять память в зависимости от количества отдельных ссылок в
 *нашем списке. Как только lst->next станет равным NULL, мы выйдем из
 *рекурсии и вернем новый список.*/

t_list	*ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *))

{
	t_list	*elem;
	t_list	*ptr;

	ptr = NULL;
	while (lst)
	{
		elem = ft_lstnew((*f)(lst->content));
		if (!elem)
		{
			ft_lstclear(&ptr, (*del));
			return (NULL);
		}
		ft_lstadd_back(&ptr, elem);
		lst = lst->next;
	}
	return (ptr);
}
